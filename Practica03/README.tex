\documentclass{article}

% Symbols
\usepackage{amsfonts, amsthm}
\usepackage{upgreek}
\usepackage{physics}
\usepackage{cancel}
\usepackage{amssymb, latexsym, amsmath}

%Algorithms
\usepackage[ruled,lined,linesnumbered,commentsnumbered]{algorithm2e}

%% Identación
\setlength{\parindent}{0cm}

% Código
\newcommand{\code}[1]{\textcolor{white!25!black}{\texttt{#1}}}
\usepackage{listings}

%AMS
\usepackage{amsthm}
\newtheorem{algo-thm}{Algoritmo}

% Graphics
\usepackage{graphicx}
\usepackage{pgf}

% Margins
\addtolength{\voffset}{-1.5cm}
\addtolength{\hoffset}{-1.5cm}
\addtolength{\textwidth}{3cm}
\addtolength{\textheight}{3cm}

%Header-Footer
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{1pt}

\newcommand{\set}[1]{
  \left\{ #1 \right\}
}

\footskip = 50pt
\renewcommand{\headrulewidth}{1pt}

\pagestyle{fancyplain}

\begin{document}
\title{UNIVERSIDAD NACIONAL AUT\'ONOMA DE M\'EXICO\\ Facultad de Ciencias}
\author{Integrantes:\\
  Marco Silva Huerta\\
  Adri\'an Aguilera Moreno\\}
\date{}
\maketitle
\begin{center}
  \includegraphics[scale=0.20]{../Imagen/Portada.jpg}\\[0.4cm]
  \Large
  \bf{Lógica Computacional}
  \normalsize
\end{center}
\newpage
\fancyhead[r]{ Lógica Computacional 2022-2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{\LARGE{Práctica 3}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%% ESPECIFICACIONES AQUÍ %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\localtextbulletone}{\textcolor{black}{\raisebox{.45ex}{\rule{.6ex}{.6ex}}}}
\renewcommand{\labelitemi}{\localtextbulletone}
\begin{itemize}
\item \code{fnn}
  \begin{itemize}
  \item Usamos las funciones: elimImpl, elimEquiv, deMorgan para obetner la forma normal negativa,
    que estamos eliminando las implicaciones y equivalencias para después aplicar ley de De Morgan
    y negar hasta que solo variables atómicas lo estén. 
  \end{itemize}
  
\item \code{fnc}
  \begin{itemize}
  \item Aplicamos la forma normal conjuntiva más dos funciones auxiliares, una para que regresa
    un True si es que encuentra conjunciones y la otra que hace ley de distribución sobre la
    formula que se le ha pasado
  \end{itemize}
  
\item \code{unit} : en busca de aplicar la regla del unitario se emplea una función auxiliar que
  \code{elimina} un elemento de una lista. Primero se verifica que sea la cabeza de la lista, en
  ese caso se mantiene la cola de la lista y se aplica nuevamente el proceso (pues el elemento
  puede estar más de una vez en la lista, en teoría no queremos esto y buscamos evitar clausulas
  duplicadas).
\item \code{elim} : esta función aplica la regla de eliminación en el algoritmo \code{DPLL}. Esta
  función emplea una función auxiliar \code{elimPropRep} que descarta a la cabeza de la lista siempre
  que esta se encuentre contenida en la cola de la misma, en otro caso se conserva la cabeza de la
  lista y se aplica la llamada recursiva de \code{elimPropRep} a la cola de la misma. Esta función
  es muy parecida a \code{elimina}, pero en este caso no pasamos el elemento como parámetro.
\item \code{red} : con esta función buscamos aplicar la regla de reducción en el algoritmo \code{DPLL}.
  Para esto empleamos $3$ funciones auxiliares:
  \begin{itemize}
  \item[$\rightarrow$] \code{elimVar} : esta función elimina la literal que se le pasa como parámetro
    de la clausula que, de igual manera, se le pasa como parámetro.
  \item[$\rightarrow$] \code{neg} : Esta función elimina la proposición que se le pasa como parámetro,
    sin importar la estructura de esta.
  \item[$\rightarrow$] \code{dif} : realiza la diferencia entre listas, esta función se implementa bajo
    la idea de que nuestras listas tengan operaciones como los conjuntos (esto nos servirá para evitar
    repeticiones por ejemplo), pero con algún orden.
  \end{itemize}
\item \code{split}
  \begin{itemize}
  \item La regla consiste en crear dos ramas, una positiva y otra negativa sacando únicamente una variable de la formula en este caso tomamos la primera y hacemos los dos caminos negando la variable de la segunda, hacemos una lista de las formulas y como sabemos que la primera variable de la formula será a la que le hacemos ramas, usando una función \textit{cabeza} obtenemos la letra que después pasamos a variable.  
  \end{itemize}
\item \code{conflict} : si se llega a la clausula vacia o no se obtiene algún modelo, entonces se lanza
  \code{True} como respuesta. En otro caso, se regresa \code{False}.
\item \code{succes} : en caso de que nuestra fórmula se vuelva la vacía, hemos encontrado un modelo y
  \code{succes} devuelve \code{True}, en otro caso devuelve \code{False}.
\item \code{appDPLL} : solo manda a llamar las funciones ya implementadas.
\end{itemize}

\begin{center}
  \fbox{
    \begin{minipage}[b][1\height]%
      [t]{0.867\textwidth}
      Matriculas:
      \begin{itemize}
      \item[1.] Marco Silva Huerta: 316205326.
      \item[2.] Adrian Aguilera Moreno: 421005200.
      \end{itemize}
  \end{minipage}}
\end{center}

\end{document}
